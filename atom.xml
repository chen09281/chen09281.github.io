<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>金锦鲤X&#39;blog</title>
  
  <subtitle>记录生活美好，记录笔记</subtitle>
  <link href="http://tang.apexlegends.icu/atom.xml" rel="self"/>
  
  <link href="http://tang.apexlegends.icu/"/>
  <updated>2023-08-05T15:54:10.819Z</updated>
  <id>http://tang.apexlegends.icu/</id>
  
  <author>
    <name>金锦鲤</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>往日重现</title>
    <link href="http://tang.apexlegends.icu/posts/d693df11.html"/>
    <id>http://tang.apexlegends.icu/posts/d693df11.html</id>
    <published>2023-08-05T23:46:32.000Z</published>
    <updated>2023-08-05T15:54:10.819Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230804_160703(1).jpg"></p><p>フラッシュバッカー</p><p>転換点いつかノートに<br>te n ka n te n i tsu ka noo to ni<br>终有一日笔记本上会出现转折点</p><p>書いたあの言葉たちは<br>ka i ta a no ko to ba ta chi wa<br>那些曾写下的那些华语</p><p>きっと泡になって消えた<br>ki tto a wa ni na tte ki e ta<br>肯定会化作泡沫逝去</p><p>行方なんて終知らない<br>yu ku e na n te shi ra na i<br>从此无影无终</p><p>擦切った白いチョコークが<br>su ri ki tta shi ro i choo ku ga<br>一支破旧的白色粉笔</p><p>はらはらと落ちていった<br>ha ra ha ra to o chi te i i tta<br>静静地从桌面落下</p><p>まるで星屑みたいだと<br>ma ru te ho shi zu mi ta i da to<br>宛如星尘般美丽</p><p>見とれていたんだ嗚呼<br>mi to re te i ta n da a a<br>深深的将我吸引</p><p>いつかわ消えてしまうけど<br>i tsu ka wa ki e te shi ma u ke do<br>即便终有一日会消失</p><p>誰かの記憶にわ残れるかな<br>da re ka no ki o ku ni wa no ko re ru ka na<br>是否能将它留在某人的记忆中呢</p><p>この瞬間を切り取ってさ<br>ko no shu n ka n wo ki ri to tte sa<br>将这美好的瞬间</p><p>光る朝が朝が<br>hi ka ru a sa ga a sa ga<br>闪耀着阳光的早晨</p><p>あまりに眩しい眩しいからさ<br>a mu i ni ma bu shi i ma bu shi i ka ra sa<br>实在是太过耀眼</p><p>なんかもうそれだけで<br>na n ka mo u so re da ke de<br>但总觉仅是如此</p><p>心が宙に舞う<br>ko ko ro ga chu u ni ma u<br>我的心也已浮于空中</p><p>君の言葉がずっと<br>ki mi no ko to ba ga zu tto<br>你的话语总是那样</p><p>離れない離れない<br>ha re na i ha re na i<br>不离不弃 伴我左右</p><p>フラッシュバッカー<br>fu ra sshu ba kkaa<br>它总能在不觉间闪现与心头</p><p>今も思い出してる<br>i ma mo o mo i da shi te ru<br>就像此刻也是一样</p><p>薄明に染まる空が<br>ha ku me i ni so ma ru so ra ga<br>薄暮染上天空</p><p>淡い彩りこぼして<br>a wa i i ro do ri ko bo shi te<br>溢出淡淡彩色</p><p>こんなちっぽけな僕の<br>ko n na chi ppo ke na bo ku no<br>它将无比渺小的我</p><p>背中を包んでく<br>se na ka wo tsu tus n de ku<br>从背后轻轻的包裹</p><p>透明なこの体は<br>to u me i na ko no ka ra da wa<br>这透明的身体</p><p>何色に成れるの？<br>na ni i ro ni na re ru no?<br>会变成什么颜色呢</p><p>ただ水のように流れ<br>ta da mi zu no yo u ni na ga re<br>还是像水流一样流淌</p><p>消えてゆくだけ？ねえ<br>ke e te yu ku da ke? na e<br>然后消逝呢？呐</p><p>ぼやけたままのフォーヵスじゃ<br>bo ya ke ta ma ma no foo ka su ja<br>如此模糊的焦点</p><p>君のㇹンモノは写せないよ<br>ki mi no ho n mo wa u tsu se na i yo<br>根本拍不到你最真实的样子嘛</p><p>寂しげな顔で君が笑う<br>sa bi shi ge na ka o de ki mi ga wa ra u<br>你带着落寞的表情对我笑道</p><p>光る朝が朝が<br>hi ka ru a sa ga a sa ga<br>闪耀着阳光的早晨</p><p>あまりに眩しい眩しいからさ<br>a ma i ni mu bu shi i ma bu shi i ka ra sa<br>是在是太过耀眼</p><p>ちょっとらしくわない<br>cho tto sa ra shi ku wa na i<br>即便还是不是完全</p><p>未来も信じちゃうよ<br>mi ra i mo shi n ji cha u yo<br>但我也开始尝试相信未来了</p><p>君の言葉がずっと<br>ki mi no ko to ba ga zu tsu tto<br>你的话语总是那样</p><p>離れない離れない<br>ha na re na i ha na re na i<br>不离不弃 伴我身旁</p><p>フラッシュバッカー<br>fu ra sshu ba kkaa<br>它总能不觉间现于心头</p><p>今も思い出してる<br>i ma mo o mo i da shi te ru<br>就像此时此刻也是一样</p><p>光る朝朝が朝が<br>hi ka ru a sa ga a sa ga<br>闪耀着阳光的早晨</p><p>あまりに眩しい眩しいからさ<br>a ma i ni ma bu shi i ma bu shi i ka ra sa<br>是在是太过耀眼</p><p>なかもうそれだけで<br>na ka mo u  so re da ke<br>但总觉仅是如此</p><p>心が宙に舞う<br>ko ko ro ga chu u ni ma u<br>我的心也浮于空中</p><p>君の言葉をぎゆっと<br>ki mo no ko to ba wo gi yu tto<br>你的话语总是那样</p><p>離さない離さない<br>ha na sa na i ha na sa na i<br>不离不弃 伴我成长</p><p>フラッシュバッカー<br>fu ra sshu ba kkaa<br>它总能在不觉间浮现于心头</p><p>今も思い出してる<br>i ma mo o mo i da shi te ru<br>就像此时此刻也是一样</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230804_160703(1).jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;フラッシュバッカー&lt;/p&gt;
&lt;p&gt;転換点いつかノートに&lt;br&gt;te n </summary>
      
    
    
    
    
    <category term="acg" scheme="http://tang.apexlegends.icu/tags/acg/"/>
    
  </entry>
  
  <entry>
    <title>c++笔记</title>
    <link href="http://tang.apexlegends.icu/posts/11eeef0e.html"/>
    <id>http://tang.apexlegends.icu/posts/11eeef0e.html</id>
    <published>2023-06-26T14:33:48.000Z</published>
    <updated>2023-08-05T15:54:10.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-局部静态如何定义"><a href="#C-局部静态如何定义" class="headerlink" title="C++局部静态如何定义"></a>C++局部静态如何定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">return</span> instance; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>以Log例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Level</span></span><br><span class="line">&#123;</span><br><span class="line">LevelError = <span class="number">0</span>,LevelWarning,LevelInfo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Level m_LogLevel = LevelInfo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(Level level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_LogLevel = level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LevelError)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[ERROR]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LevelWarning)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[WARNING]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LevelInfo)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[INFO]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Log log;</span><br><span class="line">log.<span class="built_in">SetLevel</span>(Log::LevelError);</span><br><span class="line">log.<span class="built_in">Warn</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">log.<span class="built_in">Error</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">log.<span class="built_in">Info</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在java或其他语言中，float会自动赋值为0，而c++不会所以所有变量在定义的时候都要初始化，重点作用就是初始化类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">float</span> X, Y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">float</span> x, <span class="type">float</span> y)</span><br><span class="line">&#123;</span><br><span class="line">X = x;</span><br><span class="line">Y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; X  &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; Y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数的意思是当超出作用域时候就销毁这个类，和构造函数不同区别在定义，构造函数是<code>Entity</code>，析构函数是<code>~Entity</code>前面有一个波浪号~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">float</span> X, Y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">&#123;</span><br><span class="line">X = <span class="number">0.0f</span>;</span><br><span class="line">Y = <span class="number">0.0f</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Entity</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; X  &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; Y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果不这样做，可能会造成内存泄漏，因为c++没有自动垃圾回收机制。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承写法就是加<code>:</code>例如<code>class Player : public Entity</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">float</span> X, Y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">float</span> xa, <span class="type">float</span> ya)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">X += xa;</span><br><span class="line">Y += ya;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* Name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; Name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>如果你想要覆写一个函数，必须将基类中的基函数标记为虚函数，</p><p>使用方法在函数前加<code>virtual</code>,也可以使用<strong>c++11</strong>的新特性<code>override</code>,虚函数需要额外的内存来存储v表，这样才可以分配到正确的函数，包括基类中要有一个成员指针，指向v表，其次每次调用虚函数时，都需要遍历这个表，来确定要映射到那个函数，这是额外的性能损失。</p><h3 id="如果不使用虚函数"><a href="#如果不使用虚函数" class="headerlink" title="如果不使用虚函数"></a>如果不使用虚函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">: <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"><span class="built_in">PrintName</span>(e);</span><br><span class="line"></span><br><span class="line">Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line"><span class="built_in">PrintName</span>(p);</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230630133239.png"></p><p>会发现有bug</p><h3 id="使用虚函数"><a href="#使用虚函数" class="headerlink" title="使用虚函数"></a>使用虚函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">: <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"><span class="built_in">PrintName</span>(e);</span><br><span class="line"></span><br><span class="line">Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line"><span class="built_in">PrintName</span>(p);</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常的指向到了</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230630133312.png"></p><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>c++纯虚函数本质上与其他语言(如Java或C#)中的抽象方法或接口相同，纯虚函数允许我们在基类中定义一个没有实现函数，然后强制子类去实现该函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetClassName</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 定义纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> : <span class="keyword">public</span> Printable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line"><span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">: <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line"><span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Printable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(Printable* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; obj-&gt;<span class="built_in">GetClassName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"><span class="comment">//PrintName(e);</span></span><br><span class="line"></span><br><span class="line">Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line"><span class="comment">//PrintName(p);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Print</span>(e);</span><br><span class="line"><span class="built_in">Print</span>(p);</span><br><span class="line"><span class="built_in">Print</span>(<span class="keyword">new</span> <span class="built_in">A</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>和Java一样<code>private</code>(私有的),<code>protected</code>(受保护的),<code>public</code>(公开的)，c++中class默认的可见性是private，struct的默认值是public。</p><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>private意味着，只用(Only*)这个Entity类可以访问这些变量，可以读取和写入他们，这里的”Only*”要给个星号*，因为在C++中有个叫friend的东西，friend是C++关键字，它可以让类或者函数称为类Entity的朋友(友元)，firend的意思是友元，实际上可以从类中访问私有成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> X, Y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">&#123;</span><br><span class="line">X = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity e;</span><br><span class="line">e.X = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述这段代码main中的<code>e.X = 2;</code>是不可调用的</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230705141544.png"></p><p>，也无法在子类中访问X，因为这是私有的，只有Entity类和他的友元才能访问这些变量，同样适用于<code>void</code>方法</p><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>protected意思是这个类，这个Entity类和层次结结构中的所有子类，也可以访问这些符号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> X, Y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">&#123;</span><br><span class="line">X = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Player</span>()</span><br><span class="line">&#123;</span><br><span class="line">X = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity e;</span><br><span class="line">e.X = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以看到我们可在<code>Player</code>子类中调用到<code>Entity</code>的变量和方法了，但是在<code>main</code>中还是不可以</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230705142151.png"></p><h3 id="为什么不全使用public"><a href="#为什么不全使用public" class="headerlink" title="为什么不全使用public"></a>为什么不全使用public</h3><p>public公开一切纯粹是一个糟糕的想法，对于开发者和写代码而言，这是风格问题。(可见性)是让代码更加容易维护，容易理解，不管是阅读代码还是拓展代码，这与性能无关，也不会产生完全不同的代码，可见性不是cpu需要理解的东西。如果你把某件事标记为private，这基本告诉所有人，你不应该从其它类访问这个，不能从其他代码中访问，你只能在类的内部访问这个。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>c++数组就是表示一堆变量组成的集合，一般是一行相同类型的变量。c++的定义数组的方法<code>int example[]</code>例如<code>int example[5]</code>就是创建了一个5个整数的数组c++的下标也是从0开始的。数组经常和for在一起使用，因为for循环可以通过索引来遍历，在一个特定的范围内，如果我们想设置example数组中的每一个值，可以通过for循环实现。</p><p>比如给给5个赋值,有两种写法</p><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">example[i] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">example[i] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>不推荐使用<strong>2</strong>写法因为涉及到性能的问题，因为正在做小于以及等于的比较，所以他必须做等于比较，而不仅是小于比较。</p><p>数组的内存地址</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230707225308.png"></p><p>可以看到数组值一字排开，所以数组最重要的一点是，他们连续的存储数据。这意味着他们他们数据放在了一排。每个整数是4个字节，因为这里定义了5个，所以这里得到的是一行20字节的内存，他被分成几个4字节段。并不是真的分成了4字节段。数组实际上只是一个指针，一个整形指针在这种情况下通过这段内存它包含五个整数，这意味着可以在这里创建一个变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> example[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* ptr = example;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">example[i] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">example[<span class="number">2</span>] = <span class="number">5</span>; <span class="comment">// 同样作用</span></span><br><span class="line">*(<span class="type">int</span>*)((<span class="type">char</span>*)ptr + <span class="number">8</span> ) = <span class="number">6</span>; <span class="comment">// 同样作用</span></span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两的意思是一样的，因为数组就是指针</p><p>打上断点看到索引2的元素已经被设为5了</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230707230408.png"></p><p>点一下f10他就会变成下一行所定义的6了</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230707230501.png"></p><p>同样我们也可以通过使用new来创建一个数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* another = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>这个和上面的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> example[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>是一个意思但是他们的生存期不一样，这个实在栈上创建的当我们到达最后的花括号时，它会被销毁，因为跳出了作用域范围，然而如果是在堆上创建的话直到我们程序把它销毁之前，他都是处于活动状态的。所以你需要使用delete关键字来删除，因为这是一个数组，我们在这里使用数组的操作符[]来分配(内存)。</p><p>用new来分配的内存，他将一直存在，直到你删除他，例如如果你有一个函数返回一个数组，你必须使用一个new关键字来分配他，除非你传入一个数组的地址参数，如果你想返回一个数组，这个数组是在函数中创建的你需要使用new关键字。</p><h3 id="c-11新特性数组"><a href="#c-11新特性数组" class="headerlink" title="c++11新特性数组"></a>c++11新特性数组</h3><p>定义方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; another;</span><br></pre></td></tr></table></figure><p>需引入array包，比旧方法更安全。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>本质上说字符串是一个接一个字符的一组字符(字母、数字、符号)，这类东西基本上就是文本，对于我们来说很常见。</p><h3 id="定义一个字符串"><a href="#定义一个字符串" class="headerlink" title="定义一个字符串:"></a>定义一个字符串:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;Cherno&quot;</span>;</span><br></pre></td></tr></table></figure><p>这个字符串的内存地址</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230708000155.png"></p><p>可以看到一个被设为0的字节，这被称为<strong>空终止字符</strong>，这样就知道那是字符串结束的地方。</p><h3 id="使用自定义的字符串"><a href="#使用自定义的字符串" class="headerlink" title="使用自定义的字符串"></a>使用自定义的字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name2[<span class="number">6</span>] = &#123; <span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230708000721.png"></p><p>可以看到内存设置为cc，这实际上是一个数组守卫，让我们知道内存是在我们的分配之外。所以就会出现乱码</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230708000835.png"></p><p>添加0来结束</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name2[<span class="number">7</span>] = &#123; <span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230708001242.png"></p><p>在c++中使用字符串，应该使用<strong>std::string</strong></p><h3 id="string的使用方法"><a href="#string的使用方法" class="headerlink" title="string的使用方法"></a>string的使用方法</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string name = <span class="string">&quot;Cherno&quot;</span></span><br></pre></td></tr></table></figure><p>string有一个构造函数，他接受char *或const chat *参数,不加<strong>string</strong>包也可以使用string但是在旧版的c++中打印输出的时候会报错，新的好像不会</p><h4 id="string内的方法"><a href="#string内的方法" class="headerlink" title="string内的方法"></a>string内的方法</h4><table><thead><tr><th>使用方法</th><th>作用</th></tr></thead><tbody><tr><td>size</td><td>字符串的大小</td></tr><tr><td>strlen</td><td>字符串的长度</td></tr><tr><td>strcpy</td><td>复制字符串</td></tr></tbody></table><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string name = std::<span class="built_in">string</span>(<span class="string">&quot;Cherno&quot;</span>)+<span class="string">&quot;hello!&quot;</span>;</span><br></pre></td></tr></table></figure><p>因为可以看到name的本质其实上是指针，所以并不可以直接拼接，所以要重新使用一个string。</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230708002957.png"></p><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><h3 id="几种字符串的类型"><a href="#几种字符串的类型" class="headerlink" title="几种字符串的类型"></a>几种字符串的类型</h3><h4 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* name2 = <span class="string">L&quot;Cherno&quot;</span>; <span class="comment">// 需要在字符串前添加大写L</span></span><br></pre></td></tr></table></figure><h4 id="char16-t"><a href="#char16-t" class="headerlink" title="char16_t"></a>char16_t</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char16_t</span>* name3 = <span class="string">u&quot;Cherno&quot;</span>; <span class="comment">// 需要在字符串前添加小写u这里的16指的的是utf-16</span></span><br></pre></td></tr></table></figure><h4 id="char32-t"><a href="#char32-t" class="headerlink" title="char32_t"></a>char32_t</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char32_t</span>* name4 = <span class="string">U&quot;Cherno&quot;</span>; <span class="comment">// 需要在字符串前添加大写U这里的32指的的是utf-32</span></span><br></pre></td></tr></table></figure><p>默认的char是utf-8</p><h3 id="R的作用"><a href="#R的作用" class="headerlink" title="R的作用"></a>R的作用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* example = <span class="string">R&quot;(Line1</span></span><br><span class="line"><span class="string">Line2</span></span><br><span class="line"><span class="string">Line3</span></span><br><span class="line"><span class="string">Line4)&quot;</span>; <span class="comment">// 加了R会自动转义符和这段和下面加了\n的是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ex = <span class="string">&quot;Line1\n&quot;</span> <span class="string">&quot;Line2\n&quot;</span> <span class="string">&quot;Line3\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>这两段代码都是同一个意思</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230708182114.png"></p><h2 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h2><p>const基本上就像你做出的承诺，他承诺某些东西将是不变的，也就是说他不会改变。然而它只是一个你可以绕过的承诺你可以打破你的承诺，你是否遵守诺言取决于你自己。</p><h3 id="违背const的方法"><a href="#违背const的方法" class="headerlink" title="违背const的方法"></a>违背const的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_AGE = <span class="number">90</span>; <span class="comment">// 声明MaxAge是一个常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">*a = <span class="number">2</span>;</span><br><span class="line">a = (<span class="type">int</span>*)&amp;MAX_AGE; <span class="comment">// 使用逆向引用(dereference)，然后写入</span></span><br><span class="line">std::cout &lt;&lt; *a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p>他这样也是可以工作的</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230709192812.png"></p><p>因为在这里做的是重新分配了指针指向，所以可以干两件事，1.可以改变指针的内容，也就是指针指向内存的内容。2.可以改变指针指向的地址。</p><h3 id="const在不同位置的作用"><a href="#const在不同位置的作用" class="headerlink" title="const在不同位置的作用"></a>const在不同位置的作用</h3><h4 id="const在前"><a href="#const在前" class="headerlink" title="const在前"></a>const在前</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_AGE = <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 把const放在int*前</span></span><br><span class="line"><span class="comment">// int const* a = new int; 这行代码与上一行是同样作用，只是不同风格写法</span></span><br><span class="line"></span><br><span class="line">*a = <span class="number">2</span>;</span><br><span class="line">a = (<span class="type">int</span>*)&amp;MAX_AGE;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; *a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230709193158.png"></p><p>可以看到改变<code>a</code>是不可以的，但是可以读取<code>a</code>，可以在这里逆向引用他，并打印它。</p><h4 id="const在后"><a href="#const在后" class="headerlink" title="const在后"></a>const在后</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_AGE = <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>*  <span class="type">const</span> a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">*a = <span class="number">2</span>;</span><br><span class="line">a = (<span class="type">int</span>*)&amp;MAX_AGE;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; *a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p>和上面就反过来了，我可以改变指针指向的内容，但我不能把实际的指针本身重新赋值，指向别的东西。</p><h4 id="两边都加const"><a href="#两边都加const" class="headerlink" title="两边都加const"></a>两边都加const</h4><p>很好理解，既不能改变指针指向的内容，也不可把实际的指针本身重新赋值。</p><h3 id="在类中使用const"><a href="#在类中使用const" class="headerlink" title="在类中使用const"></a>在类中使用const</h3><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_X, m_Y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_X;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里加const的作用是，承诺这个方法不会修改实际的类,如果在里面修改会报错。</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230709194133.png"></p><p>这个方法只能读取数据，但在这里不会发生任何改变。一般只有在get方法使用const，set方法就算了。</p><h4 id="在const方法中修改变量的方法"><a href="#在const方法中修改变量的方法" class="headerlink" title="在const方法中修改变量的方法"></a>在const方法中修改变量的方法</h4><p>c++中有一个关键字<code>mutable</code>允许函数是常量方法，但是可以修改变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_X, m_Y;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> var;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">var = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> m_X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_X = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><p>这个关键词的意思就是在const中可以改变变量，通常用于const方法和<strong>lambda</strong>表达式中</p><h3 id="const方法中"><a href="#const方法中" class="headerlink" title="const方法中"></a>const方法中</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_Name;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_DebugCount = <span class="number">0</span>; <span class="comment">// 添加了mutable变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_DebugCount++; <span class="comment">// 因为添加了mutable所以在此处可以更改值</span></span><br><span class="line"><span class="keyword">return</span> m_Name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="lambda中"><a href="#lambda中" class="headerlink" title="lambda中"></a>lambda中</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=]() <span class="keyword">mutable</span></span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="成员的初始化列表"><a href="#成员的初始化列表" class="headerlink" title="成员的初始化列表"></a>成员的初始化列表</h2><h3 id="不使用特性方法的原版代码"><a href="#不使用特性方法的原版代码" class="headerlink" title="不使用特性方法的原版代码"></a>不使用特性方法的<strong>原版</strong>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_Name;</span><br><span class="line"><span class="type">int</span> m_Score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">&#123;</span><br><span class="line">        m_Name = <span class="string">&quot;Unknow&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">&#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity e0;</span><br><span class="line">std::cout &lt;&lt; e0.<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Entity <span class="title">e1</span><span class="params">(<span class="string">&quot;Cherno&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; e1.<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230713112807.png"></p><h3 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_Name;</span><br><span class="line"><span class="type">int</span> m_Score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">: <span class="built_in">m_Name</span>(<span class="string">&quot;Unknow&quot;</span>),<span class="built_in">m_Score</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// m_Name  = &quot;Unknow&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">: <span class="built_in">m_Name</span>(name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//m_Name = name;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity e0;</span><br><span class="line">std::cout &lt;&lt; e0.<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Entity <span class="title">e1</span><span class="params">(<span class="string">&quot;Cherno&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; e1.<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果是一样的</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230713112807.png"></p><h3 id="为什么应该使用成员初始化"><a href="#为什么应该使用成员初始化" class="headerlink" title="为什么应该使用成员初始化"></a>为什么应该使用成员初始化</h3><p>使用成员初始化能提高性能</p><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>创建一个类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Example</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Example</span>(<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Created Entity with &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在Entity里调用Example</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_Name;</span><br><span class="line">Example m_Example;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">: <span class="built_in">m_Name</span>(<span class="string">&quot;Unknow&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// m_Name  = &quot;Unknow&quot;;</span></span><br><span class="line">m_Example = <span class="built_in">Example</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">: <span class="built_in">m_Name</span>(name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//m_Name = name;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity e0;</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在输出的时候可以发现创建了两个Example</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230713124414.png"></p><p>使用成员初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_Name;</span><br><span class="line">Example m_Example;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">: <span class="built_in">m_Name</span>(<span class="string">&quot;Unknow&quot;</span>), <span class="built_in">m_Example</span>(<span class="built_in">Example</span>(<span class="number">8</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// m_Name  = &quot;Unknow&quot;;</span></span><br><span class="line"><span class="comment">//m_Example = Example(8);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">: <span class="built_in">m_Name</span>(name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//m_Name = name;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity e0;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现只调用了一次</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230713124532.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-局部静态如何定义&quot;&gt;&lt;a href=&quot;#C-局部静态如何定义&quot; class=&quot;headerlink&quot; title=&quot;C++局部静态如何定义&quot;&gt;&lt;/a&gt;C++局部静态如何定义&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    
    <category term="C++" scheme="http://tang.apexlegends.icu/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题</title>
    <link href="http://tang.apexlegends.icu/posts/20802113.html"/>
    <id>http://tang.apexlegends.icu/posts/20802113.html</id>
    <published>2023-05-28T14:17:42.000Z</published>
    <updated>2023-08-05T15:54:10.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-css"><a href="#1-css" class="headerlink" title="1.css"></a>1.css</h1><ol><li><p>盒模型</p><p>在HTML页面中的所有元素都可以看成是一个盒子</p><p>盒子的组成：内容content、内边距padding、边框border、外边距margin</p><p>盒模型的类型:</p><p>​标准盒模型</p><p>​margin+border+padding+content</p><p>​IE盒模型</p><p>​margin+content(border+padding)</p><p>​控制盒模型的模式: box-sizing:content-box（默认值，标准盒模型）、border-box（IE盒模型）</p></li><li><p>CSS选择器的优先级</p><p>CSS的特性:继承性、层叠性、优先级</p><p>​优先级：写CSS样式的时候，会给同一个元素添加多个样式，此时谁的权重高就显示谁的样式。</p><p>​标签、类&#x2F;伪类&#x2F;属性、全局选择器、行内样式、id、!important</p><p>​!important &gt; 行内样式 &gt; id &gt; 类&#x2F;伪类&#x2F;属性 &gt; 标签 &gt; 全局选择器</p></li><li><p>隐藏元素的方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 元素在页面上消失，不占据空间</span><br><span class="line"><span class="attribute">display</span>: none; </span><br><span class="line"># 设置了元素的透明度为<span class="number">0</span>，元素不见，占据空间位置</span><br><span class="line"><span class="attribute">opacity</span>: <span class="number">0</span>; </span><br><span class="line"># 让元素消失，占据空间位置，一种不可见的状态</span><br><span class="line"><span class="attribute">visibility</span>: hidden;</span><br><span class="line"><span class="attribute">position</span>: absolute; </span><br><span class="line"><span class="attribute">clip-path</span> # 剪切掉</span><br></pre></td></tr></table></figure></li><li><p>px和rem的区别</p><p>px是像素，显示器上给我们呈现画面的像素，每个像素的大小是一样的，绝对单位长度。</p><p>rem是一种相对单位，相对于html根节点的font-size的值，直接给html节点的font-size:62.5%。</p><p><strong>1rem &#x3D; 10px; (16px*62.5% &#x3D; 10px)</strong></p></li><li><p>重绘重排的区别</p><p>重排(回流)：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小</p><p>重绘：计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制</p><p>浏览器的渲染机制</p><p>对DOM的大小、位置进行修改后，浏览器需要 重新计算元素的这些几何属性，就叫重排</p><p>对DOM的样式进行修改，比如color和background-color，浏览器不需要重新计算几何属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘。</p></li><li><p>让一个元素水平垂直居中的方式</p><p>HTML:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>定位+margin</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">       <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">       <span class="attribute">position</span>: relative;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="selector-class">.son</span>&#123;</span><br><span class="line">       <span class="attribute">position</span>: absolute;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">       <span class="attribute">background-color</span>: red;</span><br><span class="line">       <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">       <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">       <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">       <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">       <span class="attribute">margin</span>: auto;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li><li><p>定位+transform</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>flex布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">         <span class="attribute">display</span>: flex;</span><br><span class="line">         <span class="attribute">justify-content</span>: center;</span><br><span class="line">         <span class="attribute">align-items</span>: center;</span><br><span class="line">         <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">         <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">         <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="selector-class">.son</span>&#123;</span><br><span class="line">         <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">         <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">         <span class="attribute">background-color</span>: green;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li><li><p>grid布局</p></li><li><p>table布局</p></li></ol></li><li><p>CSS的那些属性哪些可以继承，哪些不可继承</p><p>CSS的三大特性: 继承、层叠、优先级</p><p>子元素可以继承父类元素的样式</p><ol><li>字体的一些属性: font</li><li>文本的一些属性: line-height</li><li>元素的可见性: visibility: hidden</li><li>表格布局的属性: border-spacing</li><li>列表的属性: list-style</li><li>页面样式属性: page</li><li>声音的样式属性</li></ol></li><li><p>有没有用过预处理器</p><p>预处理器语言增加了变量、函数混入等强大的功能</p><p>SASS LESS</p></li></ol><h1 id="2-JavaScript"><a href="#2-JavaScript" class="headerlink" title="2.JavaScript"></a>2.JavaScript</h1><ol><li><p>JS由哪三部分组成</p><p>ECMAScript: JS的核心内容，描述了语言的基础语法，比如var，for，数据类型(数组、字符串、布尔值)</p><p>文档对象模型(DOM): DOM把整个HTML页面规划为元素构成的文档</p><p>浏览器对象模型(BOM): 对浏览器窗口进行访问和操作</p></li><li><p>JS有哪些内置对象</p><p>String Boolean Number Array Object Function Math Date RegExp…</p><p>Math</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">abs</span>() <span class="comment">// 算绝对值</span></span><br><span class="line"><span class="title function_">sqrt</span>() <span class="comment">// 开平方</span></span><br><span class="line"><span class="title function_">max</span>()</span><br><span class="line"><span class="title function_">main</span>()</span><br></pre></td></tr></table></figure><p>Data</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Data</span>() <span class="comment">// 实例化一个时间</span></span><br><span class="line"><span class="title function_">getYear</span>()</span><br></pre></td></tr></table></figure><p>Array</p><p>String</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">concat</span>() <span class="comment">// 连接字符串</span></span><br><span class="line"><span class="title function_">length</span>() <span class="comment">// 字符串长度</span></span><br><span class="line"><span class="title function_">slice</span>() <span class="comment">// </span></span><br><span class="line"><span class="title function_">split</span>() <span class="comment">// 拆分字符串</span></span><br></pre></td></tr></table></figure></li><li><p>操作数组的方法有哪些</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">push</span>() <span class="comment">// 向数组末尾添加一个或多个元素，并返回新的长度</span></span><br><span class="line"><span class="title function_">pop</span>() <span class="comment">// 用于删除数组的最后一个元素</span></span><br><span class="line"><span class="title function_">sort</span>() <span class="comment">// 排序</span></span><br><span class="line"><span class="title function_">splice</span>() <span class="comment">// 用于删除或添加数组中的元素</span></span><br><span class="line"><span class="title function_">unshift</span>() <span class="comment">// 向数组头部添加一个或多个元素，并返回新的长度</span></span><br><span class="line"><span class="title function_">shift</span>() <span class="comment">// 用于删除数组的第一个元素</span></span><br><span class="line"><span class="title function_">reverse</span>() <span class="comment">// 颠倒数组中的元素顺序</span></span><br><span class="line"><span class="title function_">concat</span>() <span class="comment">// 连接两个或多个数组</span></span><br><span class="line"><span class="title function_">join</span>() <span class="comment">// 把数组中的所有元素转换为一个字符串</span></span><br><span class="line"><span class="title function_">map</span>() <span class="comment">// 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</span></span><br><span class="line"><span class="title function_">filter</span>() <span class="comment">// 过滤</span></span><br><span class="line"><span class="title function_">ervery</span>() </span><br><span class="line"><span class="title function_">some</span>() <span class="comment">// 方法用于检测数组中的元素是否满足指定条件</span></span><br><span class="line"><span class="title function_">reduce</span>() <span class="comment">// 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值</span></span><br><span class="line"><span class="title function_">isArray</span>() <span class="comment">// 判断一个对象是否为数组</span></span><br><span class="line"><span class="title function_">findIndex</span>() <span class="comment">// 根据下标来找到元素</span></span><br></pre></td></tr></table></figure><p>哪些方法会改变原数组？</p><p>​<strong>push() pop() unshift() shift() sort() reverse() splice()</strong></p></li><li><p>JS对数据类型的检测方式有哪些</p><p>typeof()</p><p>instanceof()</p><p>constructor</p><p>Object.prototype.toString.call()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof() 对于基本数据类型没问题，遇到引用数据类型就不管用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">666</span>) <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// object</span></span><br><span class="line"><span class="comment">// instanceof() 只能判断引用数据类型，不能判断基本数据类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;abc&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// constructor 几乎可以判断基本数据类型和引用数据类型，如果声明了一个构造函数，并把他的原型指向了Array</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&#x27;abc&#x27;</span>).<span class="property">constructor</span> === <span class="title class_">String</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Object.prototype.toString.call()</span></span><br><span class="line"><span class="keyword">var</span> opt = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(opt.<span class="title function_">call</span>(<span class="number">2</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(opt.<span class="title function_">call</span>(<span class="literal">true</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(opt.<span class="title function_">call</span>(<span class="string">&#x27;aaa&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(opt.<span class="title function_">call</span>([]))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(opt.<span class="title function_">call</span>(&#123;&#125;))</span><br></pre></td></tr></table></figure></li><li><p>说一下闭包，闭包有什么特点？</p><p>什么是闭包？函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包</p><p>特点: 可以重复利用变量，并且这个变量不会污染全局的一种机制：这个变量是一直保存在内存中，不会被垃圾回收机制回收。</p><p>缺点: 闭包较多的时候，会消耗内存，导致页面的性能下降，在IE浏览器中才会导致内存泄漏</p><p>使用场景: 防抖、节流、函数嵌套函数避免全局污染的时候</p></li><li><p>前端的内存泄露怎么理解</p><p>JS里已经分配内存地址的对象，但是由于长时间没有释放或者没办法清除，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。</p><p>垃圾回收机制</p><p>因素: 一些未声明直接赋值的变量、一些未清空的定时器、过度的闭包、一些引用元素没有被清除。</p></li><li><p>事件委托是什么</p><p>又叫事件代理，原理就是利用了事件冒泡的机制来实现，也就是说把子元素的事件绑定到了父元素的身上如果子元素阻止了事件冒泡，那么委托也就不成立</p><p>阻止事件冒泡: <code>event.stopPropagation()``addEventListener(&#39;click&#39;,函数名,true/false)默认是false(事件冒泡),true(事件捕获)</code></p><p>好处: 提高性能，减少事件的绑定，也就减少了内存的占用</p></li><li><p>基本数据类型和引用数据类型的区别</p><p>基本数据类型：String、Number、Boolean、undefined、null</p><p>基本数据类型保存在栈内存当中，保存的就是一个具体的值</p><p>引用数据类型(复杂数据类型)：Object、Function、Array</p><p>引用数据类型保存在堆内存当中，声明一个引用类型的变量，它保存的是引用类型数据的地址</p><p>假如声明两个引用类型同时指向了一个地址的时候，修改其中一个那么另外一个也会改变</p></li><li><p>原型链</p><p>原型就是一个普通的对象，他是为构造函数的实力共享属性和方法：所有实例中引用的原型都是同一个对象</p><p>使用prototype可以把方法挂在原型上，内存值保存一份 </p><p><code>__proto__</code>可以理解为指针，实例对象中的属性,指向了构造函数的原型(prototype)</p><p>一个实例对象在调用属性和方法的时候，会依次从实例本身、构造函数原型、原型的原型上查找</p></li><li><p>new操作符具体做了什么</p></li><li><p>先创建一个空对象</p></li><li><p>把空对象和构造函数通过原型链进行链接</p></li><li><p>把构造函数的this绑定到新的空对象身上</p></li><li><p>根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要返回这个引用类型</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-css&quot;&gt;&lt;a href=&quot;#1-css&quot; class=&quot;headerlink&quot; title=&quot;1.css&quot;&gt;&lt;/a&gt;1.css&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;盒模型&lt;/p&gt;
&lt;p&gt;在HTML页面中的所有元素都可以看成是一个盒子&lt;/p&gt;
&lt;p&gt;盒子的组成：内</summary>
      
    
    
    
    
    <category term="前端" scheme="http://tang.apexlegends.icu/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>c++中的静态</title>
    <link href="http://tang.apexlegends.icu/posts/e88eb7fe.html"/>
    <id>http://tang.apexlegends.icu/posts/e88eb7fe.html</id>
    <published>2023-04-19T21:44:28.000Z</published>
    <updated>2023-08-05T15:54:10.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-中的静态-Static"><a href="#C-中的静态-Static" class="headerlink" title="C++中的静态(Static)"></a>C++中的静态(Static)</h1><p>在c++中，当你在类和结构体之外使用静态时，他只是一位置，当你声明静态函数活静态变量时， 它只会在他被声明的C++文件中被看到，如果你想在头文件中声明一个静态变量，并将该头文件包含在两个不同的c++文件中。</p><p>例:<code>在static.cpp</code>文件中声明一个静态变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> s_Variable = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>然后在主函数再声明一个<code>s_Variable</code></p><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s_Variable = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这时候编译并没有报错，运行打印的值也为10。</p><p>想要获取到<code>static.cpp</code>中的变量需要把static去掉，然后通过extern来获取。</p><p><code>static.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s_Variable = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> s_Variable;</span><br></pre></td></tr></table></figure><p>打印的结果为5。</p><p>而方法也是一样的，因为名字只能是唯一的，所以在<code>static.cpp</code>中需要添加static来修饰</p><p>例:</p><p><code>static.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不加static修饰在编译的时候链接就会出现错误。</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230419221519.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-中的静态-Static&quot;&gt;&lt;a href=&quot;#C-中的静态-Static&quot; class=&quot;headerlink&quot; title=&quot;C++中的静态(Static)&quot;&gt;&lt;/a&gt;C++中的静态(Static)&lt;/h1&gt;&lt;p&gt;在c++中，当你在类和结构体之外使用静态时，</summary>
      
    
    
    
    
    <category term="c++" scheme="http://tang.apexlegends.icu/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>如何写一个C++类</title>
    <link href="http://tang.apexlegends.icu/posts/cee8b4b6.html"/>
    <id>http://tang.apexlegends.icu/posts/cee8b4b6.html</id>
    <published>2023-04-19T20:03:10.000Z</published>
    <updated>2023-08-05T15:54:10.819Z</updated>
    
    <content type="html"><![CDATA[<p><strong>例</strong>写一个log:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LogLevelError = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LogLevelWarning = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LogLevelInfo = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_LogLevel = LogLevelInfo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_LogLevel = level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LogLevelError)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[ERROR]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LogLevelInfo)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[INFO]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LogLevelWarning)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[WARNING]:&quot;</span>&lt;&lt;message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Log log;</span><br><span class="line">log.<span class="built_in">SetLevel</span>(log.LogLevelError);</span><br><span class="line">log.<span class="built_in">Warn</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">log.<span class="built_in">Info</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">log.<span class="built_in">Error</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;例&lt;/strong&gt;写一个log:&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
    <category term="c++" scheme="http://tang.apexlegends.icu/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C++类与结构体对比</title>
    <link href="http://tang.apexlegends.icu/posts/fa4c71d4.html"/>
    <id>http://tang.apexlegends.icu/posts/fa4c71d4.html</id>
    <published>2023-04-18T10:26:09.000Z</published>
    <updated>2023-08-05T15:54:10.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-类与结构体对比"><a href="#C-类与结构体对比" class="headerlink" title="C++类与结构体对比"></a>C++类与结构体对比</h1><p>类的默认值是<strong>private</strong>的，而结构体默认是<strong>public</strong>的，例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += xa * speed;</span><br><span class="line">y += ya * speed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player player;</span><br><span class="line">player.<span class="built_in">Move</span>( <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>把public注释掉了会报错，因为class的默认值是<strong>private</strong>,但是把class换为<strong>struct</strong>后就没有报错了，因为他默认是public:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += xa * speed;</span><br><span class="line">y += ya * speed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player player;</span><br><span class="line">player.<span class="built_in">Move</span>( <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-类与结构体对比&quot;&gt;&lt;a href=&quot;#C-类与结构体对比&quot; class=&quot;headerlink&quot; title=&quot;C++类与结构体对比&quot;&gt;&lt;/a&gt;C++类与结构体对比&lt;/h1&gt;&lt;p&gt;类的默认值是&lt;strong&gt;private&lt;/strong&gt;的，而结构体默认是&lt;</summary>
      
    
    
    
    
    <category term="c++" scheme="http://tang.apexlegends.icu/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++类</title>
    <link href="http://tang.apexlegends.icu/posts/f340d9a5.html"/>
    <id>http://tang.apexlegends.icu/posts/f340d9a5.html</id>
    <published>2023-04-15T14:46:56.000Z</published>
    <updated>2023-08-05T15:54:10.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-类"><a href="#C-类" class="headerlink" title="C++类"></a>C++类</h1><p>具体的作用和c#和java是一样的，都是为了<strong>面向对象</strong>编程，但是使用方法和java略有区别。</p><p>不适用类实现玩家的话</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>咋一眼看下去好像也没啥问题，如果有三个甚至两个玩家，就会这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x1,y1;</span><br><span class="line"><span class="type">int</span> speed1;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x2,y2;</span><br><span class="line"><span class="type">int</span> speed2;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>可以看到几乎完全是一样的代码，使用类可以很好的解决这个问题。</p><p>c++中定义类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Player player; <span class="comment">// 实例化类</span></span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用和java完全一样，但是对于可见性的定义方法不一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Player player; <span class="comment">// 实例化类</span></span><br><span class="line">    player.x = <span class="number">5</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码会报错，说没有权限访问。</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230418095044.png"></p><p>因为可见性，在c++中类默认是私有的，所以要把他定义为<strong>public</strong>才可以调用。</p><h2 id="定义为public"><a href="#定义为public" class="headerlink" title="定义为public"></a>定义为public</h2><p>前面说了和java略有不同之处就在这里了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 定义为public</span></span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player player;</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>可以看到public是在类里面的，而java是定义类的时候就有了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Player</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和java一样，也可以把函数放在类里面，达到简化代码的目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += xa * speed;</span><br><span class="line">y += ya * speed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player player;</span><br><span class="line">player.<span class="built_in">Move</span>( <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-类&quot;&gt;&lt;a href=&quot;#C-类&quot; class=&quot;headerlink&quot; title=&quot;C++类&quot;&gt;&lt;/a&gt;C++类&lt;/h1&gt;&lt;p&gt;具体的作用和c#和java是一样的，都是为了&lt;strong&gt;面向对象&lt;/strong&gt;编程，但是使用方法和java略有区别。&lt;/</summary>
      
    
    
    
    
    <category term="C++" scheme="http://tang.apexlegends.icu/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>c++引用</title>
    <link href="http://tang.apexlegends.icu/posts/92ec66fa.html"/>
    <id>http://tang.apexlegends.icu/posts/92ec66fa.html</id>
    <published>2023-04-12T12:55:33.000Z</published>
    <updated>2023-08-05T15:54:10.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用并不是一个变量，虽然他和变量的定义方法类似，不能为空。</p><p>如果只是使用指针使a发生变化的话需要加较多的符号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*value)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(&amp;a);</span><br><span class="line"><span class="built_in">LOG</span>(a);</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>使用引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(a);</span><br><span class="line"><span class="built_in">LOG</span>(a);</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>最终的输出值都为6.</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230412134320.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;p&gt;引用并不是一个变量，虽然他和变量的定义方法类似，不能为空。&lt;/p&gt;
&lt;p&gt;如果只是使用指针使a发生变化的话需要加较多的符号。&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    
    <category term="C++" scheme="http://tang.apexlegends.icu/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>c++指针</title>
    <link href="http://tang.apexlegends.icu/posts/28e39982.html"/>
    <id>http://tang.apexlegends.icu/posts/28e39982.html</id>
    <published>2023-04-12T11:55:30.000Z</published>
    <updated>2023-08-05T15:54:10.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p><strong>指针变量是存放一个内存地址的变量，不同于其他类型变量，它是专门用来存放内存地址的，也称为地址变量。定义指针变量的一般形式为：类型说明符*变量名。</strong></p><h2 id="指针的定义和使用"><a href="#指针的定义和使用" class="headerlink" title="指针的定义和使用"></a>指针的定义和使用</h2><p>想获取一个地址可以使用**&amp;**来获取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var; <span class="comment">// 定义一个指针，获取它的地址</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用debug的内存窗口可以看到指向的就是8这个值。</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230412123319.png"></p><p> 指针的变量类型并不会影响获取的地址,例如这里使用void。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">void</span>* ptr = &amp;var;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230412123619.png"></p><p>在地址中同样也是8这个值。</p><h2 id="修改里面的值"><a href="#修改里面的值" class="headerlink" title="修改里面的值"></a>修改里面的值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var;</span><br><span class="line">*ptr = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">LOG</span>(&amp;var);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><code>*ptr</code>表示逆用这个值，来修改他的参数。debug后可以看到有所变化。</p><p>这是没执行到<code>*ptr</code>地址指向的值</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230412123925.png"></p><p>F10以后可以发现变成0a了，在16进制中0a表示10</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230412124030.png"></p><p>在终端中输出的值也为10</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230412124109.png"></p><h2 id="使用指针来开辟新的内存空间"><a href="#使用指针来开辟新的内存空间" class="headerlink" title="使用指针来开辟新的内存空间"></a>使用指针来开辟新的内存空间</h2><p>我们可以使用char来开辟，char所占用的空间为1bit，所以我们可以这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>]; </span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span>); <span class="comment">// 开辟8bit的空间，并且设置为0</span></span><br></pre></td></tr></table></figure><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230412125344.png"></p><p>可以看到开辟了8bit的空间</p><h2 id="删除空间"><a href="#删除空间" class="headerlink" title="删除空间"></a>删除空间</h2><p>可以使用<code>delete</code>这个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230412125432.png"></p><h2 id="多指针"><a href="#多指针" class="headerlink" title="多指针"></a>多指针</h2><p>我们也可以定义多个指针。</p><p>例如这里指向<code>buffer</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>** ptr = &amp;buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在内存中可以看到他的值</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230412125211.png"></p><p>把这个值的参数倒转写 ，可以发现他指向的就是buffer的地址</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230412125344.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;指针&quot;&gt;&lt;a href=&quot;#指针&quot; class=&quot;headerlink&quot; title=&quot;指针&quot;&gt;&lt;/a&gt;指针&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;指针变量是存放一个内存地址的变量，不同于其他类型变量，它是专门用来存放内存地址的，也称为地址变量。定义指针变量的一般形式为：</summary>
      
    
    
    
    
    <category term="C++" scheme="http://tang.apexlegends.icu/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++控制流语句</title>
    <link href="http://tang.apexlegends.icu/posts/8c59ac7d.html"/>
    <id>http://tang.apexlegends.icu/posts/8c59ac7d.html</id>
    <published>2023-04-06T19:50:20.000Z</published>
    <updated>2023-08-05T15:54:10.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-控制流语句"><a href="#C-控制流语句" class="headerlink" title="C++控制流语句"></a>C++控制流语句</h1><p><strong>和其他语言也是一样的通过<code>continue</code>和<code>break</code>来控制</strong>,<code>return</code>来返回值</p><p><strong>continue</strong>:并不会跳出循环，而是跳过这次循环</p><p><strong>break</strong>:跳出循环，不会再执行了</p><p><strong>return</strong>:返回一个数值</p><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((i+<span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><code>return</code>的区别在于，不一定在循环中，可以在任何的地方,并且会结束这个函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-控制流语句&quot;&gt;&lt;a href=&quot;#C-控制流语句&quot; class=&quot;headerlink&quot; title=&quot;C++控制流语句&quot;&gt;&lt;/a&gt;C++控制流语句&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;和其他语言也是一样的通过&lt;code&gt;continue&lt;/code&gt;和&lt;code&gt;</summary>
      
    
    
    
    
    <category term="c++" scheme="http://tang.apexlegends.icu/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++的循环</title>
    <link href="http://tang.apexlegends.icu/posts/2e3b0a65.html"/>
    <id>http://tang.apexlegends.icu/posts/2e3b0a65.html</id>
    <published>2023-04-03T20:43:27.000Z</published>
    <updated>2023-08-05T15:54:10.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C++ 循环"></a>C++ 循环</h1><h2 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h2><p>其实也和其他语言一样，例如想输出5次“Hello World”可以复制5次例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure><p>当然也可以用for循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a>While循环</h2><p>也一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i&lt;<span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><p>也是一样的，区别在于<strong>do while</strong>是先运行再判断，会保底运行一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> condition = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-循环&quot;&gt;&lt;a href=&quot;#C-循环&quot; class=&quot;headerlink&quot; title=&quot;C++ 循环&quot;&gt;&lt;/a&gt;C++ 循环&lt;/h1&gt;&lt;h2 id=&quot;For循环&quot;&gt;&lt;a href=&quot;#For循环&quot; class=&quot;headerlink&quot; title=&quot;For</summary>
      
    
    
    
    
    <category term="c++" scheme="http://tang.apexlegends.icu/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>vs设置</title>
    <link href="http://tang.apexlegends.icu/posts/d6989446.html"/>
    <id>http://tang.apexlegends.icu/posts/d6989446.html</id>
    <published>2023-04-03T19:39:55.000Z</published>
    <updated>2023-08-05T15:54:10.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vs中的设置"><a href="#vs中的设置" class="headerlink" title="vs中的设置"></a>vs中的设置</h1><h2 id="新建一个项目的结构"><a href="#新建一个项目的结构" class="headerlink" title="新建一个项目的结构"></a>新建一个项目的结构</h2><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230403194523.png"></p><p>新建好的项目在vs中是这样显示的，但是在电脑上是这样的<img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230403194647.png"></p><p>可以看到并没有分类，在文件夹中。在vs中的其实叫做过滤器，通过<code>NewProject.vcxproj.filters</code>这个文件，包含了我们创建的虚拟文件夹。这些过滤器过滤了你的源代码，但这些目录在磁盘上根本不存在。</p><p>如果创建一个文件，它实际上创建在项目文件的旁边。</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230403195041.png"></p><p>这样可能有点混乱，想要vs自动创建对应的文件夹则需要一些设置。</p><p>在vs的文件管理中，有一个按钮叫<strong>Show All Files</strong></p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230403195520.png"></p><p>点击后就可以看到文件夹的真是状态了，新建一个<strong>src</strong>文件夹，把<code>Main.cpp</code>放进去,返回过滤器中，可以看到Main.cpp还是在<strong>Source Files</strong>文件夹中。</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230403195646.png"></p><p>当我们bulid项目的时候会发现，文件夹内出现了两个debug文件夹，exe也在其中一个<strong>debug</strong>文件夹内，要修改可以右键项目选择配置。</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230403203312.png"></p><p>在这里可以修改想要存放的位置。</p><p><code>$(SolutionDir)bin\$(Platform)\$(Configuration)\</code></p><p><code>$(SolutionDir)bin\intermediates\$(Platform)\$(Configuration)\</code></p><p>当我们再次build就可以看到在对应的位置了。</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230403203404.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vs中的设置&quot;&gt;&lt;a href=&quot;#vs中的设置&quot; class=&quot;headerlink&quot; title=&quot;vs中的设置&quot;&gt;&lt;/a&gt;vs中的设置&lt;/h1&gt;&lt;h2 id=&quot;新建一个项目的结构&quot;&gt;&lt;a href=&quot;#新建一个项目的结构&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="c++" scheme="http://tang.apexlegends.icu/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++条件与分支</title>
    <link href="http://tang.apexlegends.icu/posts/f156aac3.html"/>
    <id>http://tang.apexlegends.icu/posts/f156aac3.html</id>
    <published>2023-04-03T16:12:28.000Z</published>
    <updated>2023-08-05T15:54:10.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-分支和if"><a href="#c-分支和if" class="headerlink" title="c++分支和if"></a>c++分支和if</h2><p><strong>和其他语言没有区别</strong></p><p>例:</p><p><strong>c++</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ptr = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">Log</span>(ptr);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ptr == <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Point is Hello&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Ptr is null!&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">ty</span> <span class="operator">=</span> <span class="string">&quot;sadfdasf&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(ty != <span class="literal">null</span>)&#123;</span><br><span class="line">    sout(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ty == xxx)&#123;</span><br><span class="line">    sout(<span class="string">&quot;xcxcx&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    sout(<span class="string">&quot;safsdf&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>else if实际上是在else上再if:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Log</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>)&#123; <span class="comment">// else if的原型</span></span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;456&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-分支和if&quot;&gt;&lt;a href=&quot;#c-分支和if&quot; class=&quot;headerlink&quot; title=&quot;c++分支和if&quot;&gt;&lt;/a&gt;c++分支和if&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;和其他语言没有区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;p&gt;&lt;str</summary>
      
    
    
    
    
    <category term="c++" scheme="http://tang.apexlegends.icu/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>在vs中调试代码</title>
    <link href="http://tang.apexlegends.icu/posts/6f39c4ab.html"/>
    <id>http://tang.apexlegends.icu/posts/6f39c4ab.html</id>
    <published>2023-04-01T22:15:13.000Z</published>
    <updated>2023-08-05T15:54:10.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>设置断点</li><li>逐步运行程序</li></ol><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>断点是程序中调试器将中断的点，暂停。我们可以设置断定在程序中任何的代码上，当程序执行到这里的时，将他暂停。在这个例子的整个项目中，他会挂起执行线程，这个程序的state，指的是内存。我们可以暂停我们的程序，看看他在内存中发生了什么。一个<strong>运行中</strong>的的程序所需的内存是相当大的，包括你设置的每个变量，包括要调用的函数，包括所有。当你将程序中断后，内存数据实际上还在。能查看内存，对诊断你的程序出问题的原因非常有用，通过查看内存，你可以查看每一个变量的值，比如这个变量不应该设置为这个值，看到一些显然是错误的地方。</p><h3 id="vs设置断点"><a href="#vs设置断点" class="headerlink" title="vs设置断点"></a>vs设置断点</h3><p>可以直接点击<code>F9</code>在当前代码行上设置断点，或者可以点击侧边栏上的任意地方。确保把断点打在将会被执行的代码行上。</p><h2 id="运行debug"><a href="#运行debug" class="headerlink" title="运行debug"></a>运行debug</h2><p>打好断点后直接点击运行通过调试器，确保处于debug模式下，如果处于release模式编译器实际上会改变你的代码，断点可能永远不会被触发，因为你的程序被重新安排了。</p><p>在工具栏上有几个按钮</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/SZ2F7MD9S480%60JVU7BLJPE6.png"></p><p>**Continue:**它会继续正常执行我们的代码</p><p>**step into:**进入到这行代码上的函数里面 <code>F11</code></p><p>**step over:**从当前函数跳到下一行代码 <code>F10</code></p><p>**step out:**跳出当前函数，回到调用这个函数的位置 <code>shift+F11</code></p><p>例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line">a++;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* string = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> c = string[i];</span><br><span class="line">std::cout &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行debug后下方有几个重要的窗口</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/1NGC4EM@EI2DB%253%7BU~A~%25F5.png"></p><p><strong>autos</strong> <strong>locals</strong>向你展示可能很重要的局部变量或变量，<strong>watch</strong>可以让我们观察变量,例如在name中输入a按下回车就可以看到显示的值。如果想查看字符串同样也在name输入就可以了。</p><p>可以点开内存视图，在debug-&gt;memory-&gt;memory1就可以打开了</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230401230821.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;设置断点&lt;/li&gt;
&lt;li&gt;逐步运行程序&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;断点&quot;&gt;&lt;a href=&quot;#断点&quot; class=</summary>
      
    
    
    
    
    <category term="c++" scheme="http://tang.apexlegends.icu/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++函数</title>
    <link href="http://tang.apexlegends.icu/posts/2a2eab9c.html"/>
    <id>http://tang.apexlegends.icu/posts/2a2eab9c.html</id>
    <published>2023-04-01T18:59:31.000Z</published>
    <updated>2023-08-05T15:54:10.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h1><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数:"></a>定义函数:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以不提供任何参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*<span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让函数不反回任何值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Multiply</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">5</span>*<span class="number">8</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void</code>的意思是什么都没有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">Multiply</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C++头文件"></a>C++头文件</h1><p>通过<code>#include</code><strong>预处理指令</strong>将头文件的内容放入cpp文件。因为<code>#include</code>具有复制和粘贴的能力，把文件放入另一个文件。</p><p>头文件后缀是.h</p><p>例:</p><p><strong>Log.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>Log.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Initialzing Log&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">InitLog</span>();</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pragma声明"><a href="#pragma声明" class="headerlink" title="pragma声明"></a>pragma声明</h2><p>任何以<code>#</code>开头的东西都被称为<strong>预处理器</strong>或<strong>预处理指令</strong>,意味着它将先被处理，在实际编译此文件之前。</p><p><code>pragma once</code>监督这个头文件阻止单个头文件被多次包含，并转换为单个翻译单元。</p><p>如果不使用<code>#pragma once</code>的例子:</p><p><strong>Log.h</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #pragma once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>在<code>Log.cpp</code>将<code>Log.h</code>引入两次</p><p><strong>Log.cpp</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Initialzing Log&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编译：</p><p>会出现报错</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20230401194412.png"></p><p>指的是重新定义了player结构体错误，因为结构体的名字只能是唯一的</p><h2 id="第二种方法做头文件的监督"><a href="#第二种方法做头文件的监督" class="headerlink" title="第二种方法做头文件的监督"></a>第二种方法做头文件的监督</h2><p>使用<code>#ifndef</code><strong>检查是否有一个名为xxx的符号被定义了</strong>,<code>#define</code><strong>如果没有定义，就执行下面的语句</strong>，<code>#endif</code><strong>结束判断</strong>。</p><p>例:</p><p><strong>Log.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H <span class="comment">// 检查是否有一个叫_LOG_H的符号被定义了</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H <span class="comment">// 如果没有定义，将继续在编译中包含以下代码</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>Log.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &quot;Log.h&quot;</span></span><br><span class="line"><span class="comment">// #include &quot;Common.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H <span class="comment">// 检查是否有一个叫_LOG_H的符号被定义了</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H <span class="comment">// 如果没有定义，将继续在编译中包含以下代码</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H <span class="comment">// 检查是否有一个叫_LOG_H的符号被定义了</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H <span class="comment">// 如果没有定义，将继续在编译中包含以下代码</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Initialzing Log&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了两次并没有发生报错。</p><p><strong>pragma once</strong>看起来更加简洁，几乎所有的编译器都能识别。</p><h2 id="头文件在include语句中的差异"><a href="#头文件在include语句中的差异" class="headerlink" title="头文件在include语句中的差异"></a>头文件在include语句中的差异</h2><p>有些include使用引号，有些使用尖括号。在编译程序时，他们有两种不同的含义，我们要告诉编译器，包括<strong>文件的路径是什么</strong>,如果我们要包含的文件是在其中一个文件夹里，就可以使用尖括号来告诉编译器，搜索包含路径文件夹。而引号则通常用于包含相对于当前文件的文件。尖括号只用于编译器包含路径，引号可以做一切。例如把<code>iostream</code>替换成引号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br></pre></td></tr></table></figure><p>编译也完全不会报错。</p><h2 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a>iostream</h2><p><strong>iostream</strong>看起来不像是一个文件，因为他没有任何扩展名，他其实是一个文件，但是他没有任何的拓展名，用于将c++标准库和c标准库进行区分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-函数&quot;&gt;&lt;a href=&quot;#C-函数&quot; class=&quot;headerlink&quot; title=&quot;C++函数&quot;&gt;&lt;/a&gt;C++函数&lt;/h1&gt;&lt;h2 id=&quot;定义函数&quot;&gt;&lt;a href=&quot;#定义函数&quot; class=&quot;headerlink&quot; title=&quot;定义函数:&quot;&gt;</summary>
      
    
    
    
    
    <category term="c++" scheme="http://tang.apexlegends.icu/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++变量</title>
    <link href="http://tang.apexlegends.icu/posts/487ca582.html"/>
    <id>http://tang.apexlegends.icu/posts/487ca582.html</id>
    <published>2023-03-30T20:52:29.000Z</published>
    <updated>2023-08-05T15:54:10.815Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th><strong>Type</strong></th><th><strong>Size</strong></th><th><strong>Comment</strong></th></tr></thead><tbody><tr><td><code>int</code></td><td>4 bytes</td><td>The default choice for integral values.</td></tr><tr><td><code>char</code></td><td>1 bytes</td><td>Use for ASCII characters in older C-style strings or std::string objects that will never have to be converted to UNICODE.</td></tr><tr><td><code>short</code></td><td>2 bytes</td><td></td></tr><tr><td><code>long</code></td><td>4 bytes</td><td></td></tr><tr><td><code>long long</code></td><td>8 bytes</td><td>Represents a much larger range of integer values.</td></tr><tr><td><code>unsigned char</code></td><td>1 bytes</td><td>C++ has no built-in byte type. Use <strong><code>unsigned char</code></strong> to represent a byte value.</td></tr><tr><td><code>unsigned int</code></td><td>4 bytes</td><td>Default choice for bit flags.</td></tr><tr><td><code>bool</code></td><td>1 bytes</td><td></td></tr></tbody></table><p>int:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> variable = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>float:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> variable = <span class="number">5.5f</span>;</span><br></pre></td></tr></table></figure><p>double:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> variable = <span class="number">5.5</span>;</span><br></pre></td></tr></table></figure><p>char:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="type">char</span> a = <span class="number">65</span>; <span class="comment">//ascⅡ码</span></span><br></pre></td></tr></table></figure><p>bool:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> variable = <span class="literal">true</span>; <span class="comment">// 返回值为1</span></span><br><span class="line"><span class="type">bool</span> variable = <span class="literal">false</span>; <span class="comment">// 返回值为0</span></span><br></pre></td></tr></table></figure><p>查看占用大小：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(<span class="type">bool</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Type&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Size&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Comment&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;</summary>
      
    
    
    
    
    <category term="C++" scheme="http://tang.apexlegends.icu/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>springboot实现定时事务</title>
    <link href="http://tang.apexlegends.icu/posts/8cebbe40.html"/>
    <id>http://tang.apexlegends.icu/posts/8cebbe40.html</id>
    <published>2022-10-08T18:36:18.000Z</published>
    <updated>2023-08-05T15:54:10.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现定时事务"><a href="#实现定时事务" class="headerlink" title="实现定时事务"></a>实现定时事务</h2><p>定时事务一般是指在什么时候干什么事情，在springboot中实现定时事务，你甚至可以不用导包就可以用，因为这是springboot自带的。和异步任务一样只需要在主启动类中开启对象的功能定时任务是<code>@EnableScheduling</code>,开启完成后和异步任务一样，需要在哪里使用就在那里添加，非常的方便。但是需要注意的一点是，使用的是cron表达式这个表达式具体的可以百度上查找，有生成工具还有很多的教程。<br>例如我这里的这个是，每天10点15分30执行一次，30 15 10 * * ?。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledService</span> &#123;</span><br><span class="line">    <span class="comment">// 在一个特定的时间执行这个方法 Timer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cron表达式</span></span><br><span class="line">    <span class="comment">// 秒 分 时 日 月 周几</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  30 15 10 * * ? 每天10点15分30执行一次</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 19 16 * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hell</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,你被执行了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的方法大概是这样，上面也有一段cron表达式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现定时事务&quot;&gt;&lt;a href=&quot;#实现定时事务&quot; class=&quot;headerlink&quot; title=&quot;实现定时事务&quot;&gt;&lt;/a&gt;实现定时事务&lt;/h2&gt;&lt;p&gt;定时事务一般是指在什么时候干什么事情，在springboot中实现定时事务，你甚至可以不用导包就可以用，因为</summary>
      
    
    
    
    
    <category term="Java" scheme="http://tang.apexlegends.icu/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>springboot实现邮件任务</title>
    <link href="http://tang.apexlegends.icu/posts/291b421d.html"/>
    <id>http://tang.apexlegends.icu/posts/291b421d.html</id>
    <published>2022-10-08T16:55:58.000Z</published>
    <updated>2023-08-05T15:54:10.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入环境"><a href="#引入环境" class="headerlink" title="引入环境"></a>引入环境</h2><p>在springboot中实现邮件任务其实还是很简单的因为springboot有email的starter，只需要引入配置再配置一点东西就可以完成配置了</p><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--javax.mail:配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在application里面配置邮件发送的账号</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">1219853295@qq.com</span></span><br><span class="line"><span class="comment"># 密码是在邮箱内开启stp里面的密码，非邮箱密码</span></span><br><span class="line"><span class="attr">spring.mail.password</span>= <span class="string"></span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.qq.com</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># qq邮箱需要添加这个</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.ssl.enable</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>这样我们的配置就完成了</p><h2 id="测试邮箱服务"><a href="#测试邮箱服务" class="headerlink" title="测试邮箱服务"></a>测试邮箱服务</h2><p>使用邮箱服务需要在类中引入<code>JavaMailSenderImpl</code>的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">JavaMailSenderImpl mailSender;</span><br></pre></td></tr></table></figure><p>这个类里面包含了很多的方法.</p><blockquote><p>发送简单的邮件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个简单的邮件</span></span><br><span class="line">    <span class="type">SimpleMailMessage</span> <span class="variable">mailMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">    mailMessage.setSubject(<span class="string">&quot;陈你好啊~&quot;</span>);</span><br><span class="line">    mailMessage.setText(<span class="string">&quot;谢谢你的支持！&quot;</span>);</span><br><span class="line">    mailMessage.setTo(<span class="string">&quot;weifengchen198@gmail.com&quot;</span>,<span class="string">&quot;1219853295@qq.com&quot;</span>);</span><br><span class="line">    mailMessage.setFrom(<span class="string">&quot;1219853295@qq.com&quot;</span>);</span><br><span class="line">    mailSender.send(mailMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们启动就会发现邮件可以正常的发送过来了</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20221008183059.png" alt="简单的邮件"></p><p>但是这封邮件里面只有纯文本，如果要使用附件其实也可以。</p><blockquote><p>发送复杂的邮件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads1</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个复杂的邮件</span></span><br><span class="line">    <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">    <span class="comment">// 组装</span></span><br><span class="line">    <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正文</span></span><br><span class="line">    helper.setSubject(<span class="string">&quot;陈你好啊~plus&quot;</span>);</span><br><span class="line">    helper.setText(<span class="string">&quot;&lt;p style=&#x27;color:red&#x27;&gt;谢谢你的支持&lt;/p&gt;&quot;</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附件</span></span><br><span class="line">    helper.addAttachment(<span class="string">&quot;レイラ.jpg&quot;</span>,<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\1\\Desktop\\レイラ.jpg&quot;</span>));</span><br><span class="line">    helper.addAttachment(<span class="string">&quot;birth.png&quot;</span>,<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\1\\Desktop\\birth.png&quot;</span>));</span><br><span class="line"></span><br><span class="line">    helper.setTo(<span class="string">&quot;1219853295@qq.com&quot;</span>);</span><br><span class="line">    helper.setFrom(<span class="string">&quot;1219853295@qq.com&quot;</span>);</span><br><span class="line">    mailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个里面包含了附件以及一些html的内容，setText后面跟的true表示打开html支持。我们点击启动就可以发现邮件带着附件一起发送过来了。</p><p>可以看到附件也没有损坏，html的内容也被使用了。</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20221008183516.png" alt="复杂的邮件"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入环境&quot;&gt;&lt;a href=&quot;#引入环境&quot; class=&quot;headerlink&quot; title=&quot;引入环境&quot;&gt;&lt;/a&gt;引入环境&lt;/h2&gt;&lt;p&gt;在springboot中实现邮件任务其实还是很简单的因为springboot有email的starter，只需要引入配置再配</summary>
      
    
    
    
    
    <category term="Java" scheme="http://tang.apexlegends.icu/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot实现异步任务</title>
    <link href="http://tang.apexlegends.icu/posts/7f582bc2.html"/>
    <id>http://tang.apexlegends.icu/posts/7f582bc2.html</id>
    <published>2022-10-06T14:34:50.000Z</published>
    <updated>2023-08-05T15:54:10.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建异步任务"><a href="#创建异步任务" class="headerlink" title="创建异步任务"></a>创建异步任务</h2><p>创建一个<code>AsyncService</code>里面创建一个异步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chen.springboot09test.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据正在处理...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再创建一个controller调用这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chen.springboot09test.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.chen.springboot09test.service.AsyncService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        asyncService.hello(); <span class="comment">// 停止3秒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是打开浏览器输入hello就会发现需要等3s才会出现这个ok，体验就非常差了。在springboot中可以非常方便的定义异步任务只需要在异步方法中添加<code>@Async</code>注解就可以了,记得需要在主启动类中添加开启Async注解的方法<code>@EnableAysnc</code></p><p>AsyncService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chen.springboot09test.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉spring这是一个异步的任务</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据正在处理...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chen.springboot09test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">// 开启异步注解功能</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot09TestApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Springboot09TestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们再次输入hello就会发现浏览器中并没有等待3s直接打印ok了，后台页面中则3s后才会弹出数据正在处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建异步任务&quot;&gt;&lt;a href=&quot;#创建异步任务&quot; class=&quot;headerlink&quot; title=&quot;创建异步任务&quot;&gt;&lt;/a&gt;创建异步任务&lt;/h2&gt;&lt;p&gt;创建一个&lt;code&gt;AsyncService&lt;/code&gt;里面创建一个异步方法&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    
    <category term="Java" scheme="http://tang.apexlegends.icu/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Swagger分组和接口注释及总结</title>
    <link href="http://tang.apexlegends.icu/posts/3c6ea0b6.html"/>
    <id>http://tang.apexlegends.icu/posts/3c6ea0b6.html</id>
    <published>2022-10-05T22:46:25.000Z</published>
    <updated>2023-08-05T15:54:10.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>在swagger中分组其实非常简单，只需要新建一个Docket方法就可以了，可以使用Docket里面的groupName来分开,例如我这里新建几个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置了swagger的Docket的bean实例</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">(Environment environment)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置要显示的swagger环境</span></span><br><span class="line">    <span class="comment">//        Profiles profiles = Profiles.of(&quot;dev&quot;,&quot;test&quot;);</span></span><br><span class="line">    <span class="comment">// 获取项目的环境：</span></span><br><span class="line">    <span class="comment">// 通过environment.acceptsProfiles判断是否处在自己设定的环境当中</span></span><br><span class="line">    <span class="comment">//        boolean flag = environment.acceptsProfiles(profiles);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">        .apiInfo(apiInfo())</span><br><span class="line">        .groupName(<span class="string">&quot;陈&quot;</span>)</span><br><span class="line">        <span class="comment">//                .enable(flag) // enable是否启用swagger，如果为false则swagger不能在浏览器中访问</span></span><br><span class="line">        .select()</span><br><span class="line">        <span class="comment">// RequestHandlerSelectors.配置要扫描接口的方式</span></span><br><span class="line">        <span class="comment">// any():扫描全部</span></span><br><span class="line">        <span class="comment">// none():都不扫描</span></span><br><span class="line">        <span class="comment">// withClassAnnotation:扫描类上的注解，是一个注解的反射对象</span></span><br><span class="line">        <span class="comment">// withMethodAnnotation:扫描方法上的注解</span></span><br><span class="line">        .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.chen.swagger.controller&quot;</span>))</span><br><span class="line">        <span class="comment">// paths 过滤什么路径</span></span><br><span class="line">        <span class="comment">//                 .paths(PathSelectors.ant(&quot;/chen/**&quot;))</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置swagger信息=apiInfo</span></span><br><span class="line"><span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 作者信息</span></span><br><span class="line">    <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;Chen&quot;</span>, <span class="string">&quot;https://myfake.xyz&quot;</span>, <span class="string">&quot;weifengchen198@gmail.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfo</span>(<span class="string">&quot;我的Swagger API文档&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;描述&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;https://myfake.xyz&quot;</span>,</span><br><span class="line">                       contact,</span><br><span class="line">                       <span class="string">&quot;Apache 2.0&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,</span><br><span class="line">                       <span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候进入swagger-ui的界面就可以看到有分组了,过滤或者扫描只需要像之前一样配置就可以了，每个都是独立的</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20221005225612.png" alt="分组"></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>在swagger中有很多的注释，例如<code>@ApiModel</code>:给实体类备注，<code>@ApiModelProperty</code>:给参数备注,<code>@ApiOperation</code>:给接口备注,<code>@ApiParam</code>:给请求参数备注，例如我下面这样写</p><p>User.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chen.swagger.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Api(注释)</span></span><br><span class="line"><span class="meta">@ApiModel(&quot;用户实体类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;密码&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chen.swagger.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.chen.swagger.pojo.User;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要我们的接口中，返回值存在实体类，它就会被扫描到swagger</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Operation接口</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;hello控制类&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/hello2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello2</span><span class="params">(<span class="meta">@ApiParam(&quot;用户名&quot;)</span> String username)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>+username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;Post测试类&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/postt&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">hello2</span><span class="params">(<span class="meta">@ApiParam(&quot;用户名&quot;)</span> User user)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们打开浏览器就可以看到我们添加的备注了。</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20221005230023.png" alt="备注"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>点击这些接口有一个Try it out的按钮，输入参数，然后点击Execute就可以测试查看输出的结果了，使用方法类似与postman,如果有错误也可以看到报错的信息</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20221005230224.png" alt="成功"></p><p>在上面的postt接口中我添加了<code>int i = 5/0;</code>这段是肯定会报错的会返回空指针异常，我们在swagger测试一下:</p><p><img src="https://hexo-1303188987.cos.ap-guangzhou.myqcloud.com/test/20221005230455.png" alt="错误"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>我们可以通过Swagger给一些比较难理解的属性或者接口，增加注释信息</li><li>接口文档实时更新</li><li>可以在线测试</li></ol><p>【注意点】在正式发布的时候，关闭swagger！！出于安全考虑。而且节省内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分组&quot;&gt;&lt;a href=&quot;#分组&quot; class=&quot;headerlink&quot; title=&quot;分组&quot;&gt;&lt;/a&gt;分组&lt;/h2&gt;&lt;p&gt;在swagger中分组其实非常简单，只需要新建一个Docket方法就可以了，可以使用Docket里面的groupName来分开,例如我这里新</summary>
      
    
    
    
    
    <category term="Swagger" scheme="http://tang.apexlegends.icu/tags/Swagger/"/>
    
  </entry>
  
</feed>
